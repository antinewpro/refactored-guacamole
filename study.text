基本介绍
  MVC 与 MVVM 的区别
    MVVM 是前端框架，服务于视图和模型
    VM是M与V的调度者，即Vue实例对象Vue Model
    核心功能是：实现了数据双向绑定功能
  Vue基本代码结构
    <script>
      var vm=new Vue({
          el:'元素选择器',
          data:{数据},
          methods:{方法},
      });
    </script> 

生命周期
  new Vue()
    · 初始化构建Vue实例, 并进入Vue生命周期
  beforeCreate()
    · Vue生命周期第一个钩子函数
    · 此过程中, 开始初始化Vue的数据及事件, 并对其数据进行监控
  created()
    · 所有的对象和属性都已编译到了内存之中
    · 开始寻找挂载点-el属性
      如果没有找到, 则查看vm.$mount(el), 他是一个回调函数
    · 再寻找模板-template
      如果没有找到, 则将el的父节点作为模板
    · 编译模板到渲染函数
  beforeMount()
    · 此时的html仍然没有被渲染
    · 在此钩子函数中, 将为创建vm.$el, 并用el将其替换
    这个一个细思极恐的问题：
      vm.el != el即document.getElementById('app')
  mounted()
    · 内存中的模板已经被渲染到html，此刻可以任意的操作DOM元素
    · 等待数据的改变，或是vue实例的销毁
  beforeUpdate()
    · 当数据（vm监控到的任一数据）发生变化，即触发该钩子
    · vue在beforeCreate钩子初始化时，就对所有内存中的数据进行了监控，一旦其发生变化，dom也将立即随之变化
  updated()
    · vm已经知晓了哪个属性发生了变化
    · 将内存中虚拟的DOM树更新（渲染）
    · 重新回到mounted() 钩子
  beforeDestroy()
    · 内存地址遭到破坏 - 进程死亡
      可以是人为的手动关闭浏览器，可以是服务器停掉了，也可能是发生了物理破坏
    · 此时，vm的所有数据，方法，指令…都可用
      我们可以在这里做一些缓存记录，保存本次的信息，不至于数据丢失
  destroyed()
    · 进程彻底死亡，vm死亡，内存释放，所有数据，方法，指令…都不可用
模板语法
  使用 JavaScript 表达式
    · 对于所有的数据绑定，Vue.js 都提供了完全的 JavaScript 表达式支持。
    · 从 2.6.0 开始，可以用方括号括起来的 JavaScript 表达式作为一个指令的参数：
  插值
   {{msg}}
    数据绑定最常见的形式就是使用“Mustache”语法 (双大括号) 的文本插值：
    无论何时，绑定的数据对象上 msg property 发生了改变，插值处的内容都会更新。
  指令
    v-once
      只执行一次, 包括插值
      是整个节点上的所有数据绑定只执行一次
    v-html
      双大括号的插值会将数据解释为普通文本,而非 HTML代码
    v-bind
      Mustache 语法不能作用在 HTML attribute 上，遇到这种情况应该使用 v-bind
      <button v-bind:disabled="isButtonDisabled">Button</button>
      如果 isButtonDisabled 的值是 null、undefined 或 false，则 disabled attribute 甚至不会被包含在渲染出来的 <button> 元素中。
    v-on
      动态事件
      简写 @
      如 @click 单击事件
    v-if
      <p v-if="seen">现在你看到我了</p>
      这里，v-if 指令将根据表达式 seen 的值的真假来插入/移除 <p> 元素。
    v-show
      v-show:"expression"
      效果同v-if 区别是当expression为true时 只是在节点上添加一个display: none 而v-if切换时 是将dom上的节点彻底删除 再渲染
      v-show 不仅可以绑定表达式, 还可以是一个func
    v-model
      用于动态数据双向绑定, 只能用于表单元素
      如：input{radio,text,address,email...} select checkbox textarea
    v-for
      v-for="item in arrays" 循环渲染
      从 2.0x 开始 必须指定唯一的key(并只能是string, Number)
    :缩写
      :href
        v-bind:href="url" 动态绑定url
      :[key]
        :key="value" 动态参数缩写法 2.6.0+
      :class
        v-bind:class="{'to-pay':totalPrice>=minPrice}"
        如果totalPrice>=minPrice结果为true 则使用to-pay样式
        适用不同情况情况下节点的样式变化, 支持数组
      :style
        v-bind:style="'cssInLineStyle':expression"
        类似 :class 此生成的是行内样式 
    @缩写
      @click
        v-on:click="doSomething" 点击事件
      @[event]
        @event="doSomething" 动态事件缩写 2.6.0+
  事件修饰符
    .stop（阻止冒泡）
    .prevent（阻止默认行为）
    .capture（捕获机制） 
    .self（只执行自己）
    .once（只执行一次）
    .sync (@update:counter)
      .sync 修饰符，它只是作为一个编译时的语法糖存在。它会被扩展为一个自动更新父组件属性的 v-on 侦听器。

组件通讯
  父传子
    v-bind:name="value"
    然后在子组件 props 中注册即可使用
  子传父 & 子承父
    事件分发 & 委托
      在节点上挂载@func="show" （show是父组件的方法）
      然后在子组件js中使用this.$emit('func', [this.msg]) 委托执行父组件func点击事件, 并可对其传值
    官方解读：
      $dispatch 和 $broadcast 已经被弃用。请使用更多简明清晰的组件间通信和更好的状态管理方案，如：Vuex。
      对于 $dispatch 和 $broadcast 最简单的升级方式就是：通过使用事件中心，允许组件自由交流，无论组件处于组件树的哪一层。由于 Vue 实例实现了一个事件分发接口，你可以通过实例化一个空的 Vue 实例来实现这个目的。
      这些方法的最常见用途之一是父子组件的相互通信。在这些情况下，你可以使用 v-on 监听子组件上 $emit 的变化。这可以允许你很方便的添加事件显性。
      然而，如果是跨多层父子组件通信的话，$emit 并没有什么用。相反，用集中式的事件中间件可以做到简单的升级。这会让组件之间的通信非常顺利，即使是兄弟组件。因为 Vue 通过事件发射器接口执行实例，实际上你可以使用一个空的 Vue 实例。
    子承父
      父组件拥有的数据,
      子组件可以通过$parent访问数据
      然而:组件实例的作用域是孤立的。这意味着不能 (也不应该) 在子组件的模板内直接引用父组件的数据。要让子组件使用父组件的数据，我们需要通过子组件的 props 选项。
  父调子
    挂载dom元素
      在dom节点（可以ref组件）中添加 ref="name"
      然后在js中使用this.$refs操作

      注：mounted生命周期开始才能操作dom，如果有必要，可以在created中使用this.$nextTick(() => {
              this._initScroll();
              this._calcHeight();
            });
      
      官方解读：
        在1.x的vue中 使用v-el挂载dom节点 this.$els进行操作, 使用v-ref挂载组件 this.$refs进行操作
        2.x中v-el 和 v-ref 合并为一个 ref attribute 了，可以在组件实例中通过 $refs 来调用
        另一方面，设计 $refs 主要是提供给 js 程序访问的，并不建议在模板中过度依赖使用它。因为这意味着在实例之外去访问实例状态，违背了 Vue 数据驱动的思想。
  父监子 & 子调父
    每个 Vue 实例都实现了事件接口 (Events interface)，即：
      使用 $on(eventName) 监听事件
      使用 $emit(eventName) 触发事件
  非父子 | 兄弟组件通讯
    两个非父子组件通讯，可以使用一个空的vue实例来做事件总线，在这个实例上定义和监听自定义事件。
      //空的Vue实例作为事件总线
      var eventBus = new Vue({});
      //组件A
      </span></p><input v-model="sendData"></input>
      eventBus.$emit('sendToB', this.sendData)
      eventBus.$on('sendToA', (data)=> {
          this.text = data
      }
      //组件B
      </span></p><input v-model="sendData"></input>
      eventBus.$emit('sendToA', this.sendData)
      eventBus.$on('sendToB', (data)=> {
          this.text = data
      }



css样式规范
  布局样式要写前面

将块级样式同行显示
  display: inline-block;

css中文字与文字自动对齐，而如果同行有文字还有图片或其它元素，对齐会出现问题
  解决方案：
    均设置
    vertical-align: top;

视口适应, 本项目针对iphone6开发, iphone5的布局会出现问题
  解决：
    在 .overview-left
    @media only screen and (max-width: 320px) {
        flex: 0 0 120px;
        width: 120px;
      }
    在 .overview-right
    @media only screen and (max-width: 320px) {
        padding-left: 6px;
      }

同行显示不想换行, 多余部分隐藏掉
  white-space: nowrap;

充满块
  display block

  